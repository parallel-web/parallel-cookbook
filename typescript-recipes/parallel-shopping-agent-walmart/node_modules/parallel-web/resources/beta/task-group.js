"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskGroup = void 0;
const resource_1 = require("../../core/resource.js");
const headers_1 = require("../../internal/headers.js");
const path_1 = require("../../internal/utils/path.js");
class TaskGroup extends resource_1.APIResource {
    /**
     * Initiates a TaskGroup to group and track multiple runs.
     */
    create(body, options) {
        return this._client.post('/v1beta/tasks/groups', { body, ...options });
    }
    /**
     * Retrieves aggregated status across runs in a TaskGroup.
     */
    retrieve(taskGroupID, options) {
        return this._client.get((0, path_1.path) `/v1beta/tasks/groups/${taskGroupID}`, options);
    }
    /**
     * Initiates multiple task runs within a TaskGroup.
     */
    addRuns(taskGroupID, params, options) {
        const { betas, ...body } = params;
        return this._client.post((0, path_1.path) `/v1beta/tasks/groups/${taskGroupID}/runs`, {
            body,
            ...options,
            headers: (0, headers_1.buildHeaders)([
                { ...(betas?.toString() != null ? { 'parallel-beta': betas?.toString() } : undefined) },
                options?.headers,
            ]),
        });
    }
    /**
     * Streams events from a TaskGroup: status updates and run completions.
     *
     * The connection will remain open for up to an hour as long as at least one run in
     * the group is still active.
     */
    events(taskGroupID, query = {}, options) {
        return this._client.get((0, path_1.path) `/v1beta/tasks/groups/${taskGroupID}/events`, {
            query,
            ...options,
            headers: (0, headers_1.buildHeaders)([{ Accept: 'text/event-stream' }, options?.headers]),
            stream: true,
        });
    }
    /**
     * Retrieves task runs in a TaskGroup and optionally their inputs and outputs.
     *
     * All runs within a TaskGroup are returned as a stream. To get the inputs and/or
     * outputs back in the stream, set the corresponding `include_input` and
     * `include_output` parameters to `true`.
     *
     * The stream is resumable using the `event_id` as the cursor. To resume a stream,
     * specify the `last_event_id` parameter with the `event_id` of the last event in
     * the stream. The stream will resume from the next event after the
     * `last_event_id`.
     */
    getRuns(taskGroupID, query = {}, options) {
        return this._client.get((0, path_1.path) `/v1beta/tasks/groups/${taskGroupID}/runs`, {
            query,
            ...options,
            headers: (0, headers_1.buildHeaders)([{ Accept: 'text/event-stream' }, options?.headers]),
            stream: true,
        });
    }
}
exports.TaskGroup = TaskGroup;
//# sourceMappingURL=task-group.js.map