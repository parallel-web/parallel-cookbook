// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
import { APIResource } from "../../core/resource.mjs";
import { buildHeaders } from "../../internal/headers.mjs";
import { path } from "../../internal/utils/path.mjs";
export class TaskGroup extends APIResource {
    /**
     * Initiates a TaskGroup to group and track multiple runs.
     */
    create(body, options) {
        return this._client.post('/v1beta/tasks/groups', { body, ...options });
    }
    /**
     * Retrieves aggregated status across runs in a TaskGroup.
     */
    retrieve(taskGroupID, options) {
        return this._client.get(path `/v1beta/tasks/groups/${taskGroupID}`, options);
    }
    /**
     * Initiates multiple task runs within a TaskGroup.
     */
    addRuns(taskGroupID, params, options) {
        const { betas, ...body } = params;
        return this._client.post(path `/v1beta/tasks/groups/${taskGroupID}/runs`, {
            body,
            ...options,
            headers: buildHeaders([
                { ...(betas?.toString() != null ? { 'parallel-beta': betas?.toString() } : undefined) },
                options?.headers,
            ]),
        });
    }
    /**
     * Streams events from a TaskGroup: status updates and run completions.
     *
     * The connection will remain open for up to an hour as long as at least one run in
     * the group is still active.
     */
    events(taskGroupID, query = {}, options) {
        return this._client.get(path `/v1beta/tasks/groups/${taskGroupID}/events`, {
            query,
            ...options,
            headers: buildHeaders([{ Accept: 'text/event-stream' }, options?.headers]),
            stream: true,
        });
    }
    /**
     * Retrieves task runs in a TaskGroup and optionally their inputs and outputs.
     *
     * All runs within a TaskGroup are returned as a stream. To get the inputs and/or
     * outputs back in the stream, set the corresponding `include_input` and
     * `include_output` parameters to `true`.
     *
     * The stream is resumable using the `event_id` as the cursor. To resume a stream,
     * specify the `last_event_id` parameter with the `event_id` of the last event in
     * the stream. The stream will resume from the next event after the
     * `last_event_id`.
     */
    getRuns(taskGroupID, query = {}, options) {
        return this._client.get(path `/v1beta/tasks/groups/${taskGroupID}/runs`, {
            query,
            ...options,
            headers: buildHeaders([{ Accept: 'text/event-stream' }, options?.headers]),
            stream: true,
        });
    }
}
//# sourceMappingURL=task-group.mjs.map